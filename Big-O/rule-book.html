With Big O, we worry about scalable code. 
How the code will be executed if things get bigger and bigger
https://www.bigocheatsheet.com/

Rule 1: Worst Case
    Always think of the worst case scenario to calculate the big 
    --> findNemo(fish)
        worst case: Nemo is at the last place in the array  

Rule 2: Remove constant
    Constant can be dropped while calculating the Big 0
    -->  Big O(3 + 4n) become  Big O(n)

 
Rule 3: Different terms for inputs 
    When there are different inputs, you should use different terms
    --> function compressFirstBpx(boxes, boxes2){
        console.log(boxes[0]) // Big O(a)
        console.log(boxes2[0]) // Big O(b)
    }
    Big O( a + b)

Rule 4: Drop Non Dominants
    We always just keep the most important dominant term, most significant
    -->
    function printAllNumbersThenAllPairSums(numbers) {

        console.log('these are the numbers:');
        numbers.forEach(function(number) { // Big O(n)
        console.log(number);
        });
    
        console.log('and these are their sums:');
        numbers.forEach(function(firstNumber) { // Big O(n)
        numbers.forEach(function(secondNumber) { // Big O(n))
            console.log(firstNumber + secondNumber);
        });
        });
    }
    
    printAllNumbersThenAllPairSums([1,2,3,4,5])

    As the inputs increase the size of "n^2" is always more important than the size 
    of "n"
     -> Big O( n + n^2 ) -> Big O( n^2 )
